\section{Описание контейнера}
Бинарное (двоичное) дерево (binary tree) - это упорядоченное дерево, каждая вершина которого имеет не более двух поддеревьев, причем для каждого узла выполняется правило: в левом поддереве содержатся только ключи, имеющие значения, меньшие, чем значение данного узла, а в правом поддереве содержатся только ключи, имеющие значения, большие, чем значение данного узла.

Бинарное дерево является рекурсивной структурой, поскольку каждое его поддерево само является бинарным деревом и, следовательно, каждый его узел в свою очередь является корнем дерева.

Узел дерева, не имеющий потомков, называется листом.

Схематичное изображение бинарного дерева:
\begin{center}\includegraphics{1.png}\end{center}

Организация данных с помощью бинарных деревьев часто позволяет значительно сократить время поиска нужного элемента. Поиск элемента в линейных структурах данных обычно осуществляется путем последовательного перебора всех элементов, присутствующих в данной структуре. Поиск по дереву не требует перебора всех элементов, поэтому занимает значительно меньше времени. Максимальное число шагов при поиске по дереву равно высоте данного дерева, т.е. количеству уровней в иерархической структуре дерева.

Бинарное дерево является рекурсивной структурой, поскольку каждое его поддерево само является бинарным деревом и, следовательно, каждый его узел в свою очередь является корнем дерева.

При работе с деревьями обычно используются рекурсивные алгоритмы. Использование рекурсивных функций менее эффективно, поскольку многократный вызов функции расходует системные ресурсы. Тем не менее, использование рекурсивных функций является оправданным, поскольку нерекурсивные функции для работы с деревьями гораздо сложнее и для написания, и для восприятия кода программы.

Основные операции в бинарном дереве:

\begin{itemize}
\item обход дерева;
\item добавление элемента;
\item удаление элемента;
\item поиск элемента;
\end{itemize}

\begin{center}\includegraphics{2.png}\end{center}

Операция, при которой вершины дерева поочередно просматриваются и каждая только один раз называется {\bf обходом дерева}. Выделяют четыре основных метода обхода:

\begin{itemize}
\item обход в ширину;
\item прямой обход;
\item обратный обход;
\item симметричный обход;
\end{itemize}

{\bf Обход в ширину} – это поуровневая обработка узлов слева на право. Работа этого метода заключается в просмотре всех вершин, начиная с n-ого уровня и некоторой вершины.

Возьмем нулевой уровень за начальный (рис. 2), и, начиная с вершины K, будем методом обхода в ширину поочередно двигаться вниз, просматривая при этом вершины в следующем порядке: K A X T N H Q F U P L B J V Y.

{\bf Обход в прямом порядке} вначале предполагает обработку предков, а потом их потомков, то есть сначала посещается вершина дерева, далее левое и правое поддеревья, именно в описанном порядке. Для нашего дерева последовательность прямого обхода такая: K A T F U N P L X H B J Q V Y.

{\bf Обход в обратном порядке} противоположен прямому обходу. Первыми осматриваются потомки, а уже затем предки, иначе говоря, первоначально обращение идет к элементам нижних уровней левого поддерева, потом то же самое с элементами правого, и в конце осматривается корень. Обратный обход дерева с рисунка 2: F U T P L N A B J H V Y Q X K.

{\bf Обход в симметричном порядке} заключается в посещении левого узла, перехода в корень, и оттуда в правый узел. Все для того же дерева узлы будут осмотрены в следующем порядке: F T U A P N L K B H J X V Q Y.

Узел бинарного дерева можно описать следующим образом:
\begin{lstlisting}[language=C++, caption="Описание узла бинарного дерева на С++"]
struct BTree
{
	T data;
	BTree* left;
	BTree* right;
};
\end{lstlisting}

Где Т - тип данных хранимых внутри узла, а left и right - указатели на левое и правое дочерное поддерево узла.

Как в случае со списком, программа должна хранить указатель на первый элемент дерева, его вершину, который ещё называют {\bf корнем дерева} (Root). В начале работы программы дерево пусто и корневой элемент может быть определён как {\it BTree* Root = NULL;}.

{\bf Добавление элемента в дерево.}

Процедура добавления имеет следующий алгоритм работы:
\begin{enumerate}
\item если проверяемый узел пуст, то:
\begin{enumerate}
\item создаём новый узел;
\item левый и правый указатель указывают на пусто;
\end{enumerate}
\item иначе выбираем ветку, по которой продолжим просмотр дерева. Если значение текущего элемента больше искомого, просматриваем левую ветку поддерева, в противном случае правую.
\end{enumerate}

{\bf Удаление элемента из дерева.}

Процедура удаления имеет следующий алгоритм работы:
\begin{enumerate}
\item Если текущий узел пуст, то остановиться
\item Иначе сравнить ключ искомого узла (К) с ключом текущего узла (Т).
\begin{enumerate}
\item Если K>Т, рекурсивно удалить искомый узел из правого поддерева.
\item Если K<Т, рекурсивно удалить K из левого поддерева Т.
\item Если K=Т, то необходимо рассмотреть два случая:
\begin{enumerate}
\item Если одного из детей нет, то значения полей второго ребёнка m ставим вместо соответствующих значений текущего узла, затирая его старые значения и освобождаем память, занимаемую узлом.
\item Если оба потомка присутствуют, то:
\begin{enumerate}
\item найдём узел m, являющийся самым левым узлом правого поддерева;
\item скопируем значения полей (ключ, значение) узла m в соответствующие поля узла n.
\item у предка узла m заменим ссылку на узел m ссылкой на правого потомка узла m (который, в принципе, может быть пустым).
\item освободим память, занимаемую узлом m (на него теперь никто не указывает, а его данные были перенесены в узел n).
\end{enumerate}
\end{enumerate}
\end{enumerate}
\end{enumerate}


{\bf Поиск элемента в дереве.}

Процедура поиска имеет следующий алгоритм работы:
\begin{enumerate}
\item Если дерево пусто, то сообщить, что узел не найден, и остановиться.
\item Иначе сравнить искомый ключ (К) со значением ключа текущего узла (Т).
\begin{enumerate}
\item Если K=Т, выдать ссылку на этот узел и остановиться.
\item Если K>Т, рекурсивно искать ключ K в правом поддереве Т.
\item Если K<Т, рекурсивно искать ключ K в левом поддереве Т.
\end{enumerate}
\end{enumerate}

Может возникнуть вопрос, зачем нужны такие сложности, если можно просто хранить данные в виде списка или массива. Ответ прост — операции с деревом работают быстрее. При реализации списком все функции требуют O(n) действий, где n — размер структуры. Операции с деревом же работают за O(h), где h — максимальная глубина дерева (глубина — расстояние от корня до вершины). В оптимальном случае, когда глубина всех листьев одинакова, в дереве будет n=$2^{h}$ вершин. Значит, сложность операций в деревьях, близких к оптимуму будет O($\log_{2} n$). К сожалению, в худшем случае дерево может выродится и сложность операций будет как у списка, например, если вставлять значения в порядке их возрастания или убывания.


Бинарные деревья применяются не только для хранения и поиска информации, но и используются в различных алгоритмах сортировки и сжатия данных. Кроме того, существуют более продвинутые варианты бинарных деревьев, которые используются в компьютерной графике, в играх, при создание алгоритмов принятия решений и для множества других целей.